dc.contributor.advisor,dc.contributor.author,dc.contributor.other,dc.date.accessioned,dc.date.available,dc.date.issued,dc.identifier.uri,dc.description.abstract,dc.format.extent,dc.relation.ispartofseries,dc.title,dc.rights,dc.rights.uri,dc.subject,dc.relation.replaces,dc.description,dc.format.mimetype,dc.identifier.citation,dc.relation.isreplacedby,dc.relation.uri,dc.description.sponsorship,dc.contributor.editor
Martin Rinard,"Kim, Deokhwan; Rinard, Martin C.",Computer Architecture,2010-12-03T21:00:05Z,2010-12-03T21:00:05Z,2010-12-03,http://hdl.handle.net/1721.1/60078,"Commuting operations play a critical role in many parallel computing systems. We present a new technique for verifying commutativity conditions, which are logical formulas that characterize when operations commute. Because our technique reasons with the abstract state of verified linked data structure implementations, it can verify commuting operations that produce semantically equivalent (but not identical) data structure states in different execution orders. We have used this technique to verify sound and complete commutativity conditions for all pairs of operations on a collection of linked data structure implementations, including data structures that export a set interface (ListSet and HashSet) as well as data structures that export a map interface (AssociationList, HashTable, and ArrayList). This effort involved the specification and verification of 765 commutativity conditions. Many speculative parallel systems need to undo the effects of speculatively executed operations. Inverse operations, which undo these effects, are often more efficient than alternate approaches (such as saving and restoring data structure state). We present a new technique for verifying such inverse operations. We have specified and verified, for all of our linked data structure implementations, an inverse operation for every operation that changes the data structure state. Together, the commutativity conditions and inverse operations provide a key resource that language designers and system developers can draw on to build parallel languages and systems with strong correctness guarantees.",673 p.,MIT-CSAIL-TR-2010-056,Verification of Semantic Commutativity Conditions and Inverse Operations on Linked Data Structures,,,,,,,,,,,
Tomaso Poggio,"Leibo, Joel Z; Mutch, Jim; Ullman, Shimon; Poggio, Tomaso",Center for Biological and Computational Learning (CBCL),2010-12-06T19:00:10Z,2010-12-06T19:00:10Z,2010-12-04,http://hdl.handle.net/1721.1/60216,We can immediately recognize novel objects   seen only once before -- in different positions on the retina and at different scales (distances). Is this ability hardwired by our genes or learned during development -- and if so how? We present a computational proof that developmental learning of invariance in recognition is possible and can emerge rapidly. This computational work sets the stage for experiments on the development of object invariance while suggesting a specific mechanism that may be critically tested.,4 p.,MIT-CSAIL-TR-2010-057; CBCL-293,From primal templates to invariant recognition,Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported,http://creativecommons.org/licenses/by-nc-nd/3.0/,vision; object recognition,,,,,,,,
Srini Devadas,"Kinsy, Michel; Pellauer, Michael",Computation Structures,2010-12-10T19:30:05Z,2010-12-10T19:30:05Z,2010-12-08,http://hdl.handle.net/1721.1/60266,"Heracles is an open-source complete multicore system written in Verilog. It is fully parameterized and can be reconfigured and synthesized into different topologies and sizes. Each processing node has a 7-stage pipeline, fully bypassed, microprocessor running the MIPS-III ISA, a 4-stage input-buffer, virtual-channel router, and a local variable-size shared memory. Our design is highly modular with clear interfaces between the core, the memory hierarchy, and the on-chip network. In the baseline design, the microprocessor is attached to two caches, one instruction cache and one data cache, which are oblivious to the global memory organization. The memory system in Heracles can be configured as one single global shared memory (SM), or distributed shared memory (DSM), or any combination thereof. Each core is connected to the rest of the network of processors by a parameterized, realistic, wormhole router. We show different topology configurations of the system, and their synthesis results on the Xilinx Virtex-5 LX330T FPGA board. We also provide a small MIPS cross-compiler toolchain to assist in developing software for Heracles.",9 p.,MIT-CSAIL-TR-2010-058,Heracles: Fully Synthesizable Parameterized MIPS-Based Multicore System,Creative Commons Attribution 3.0 Unported,http://creativecommons.org/licenses/by/3.0/,Multicore Architecture Design; FPGA; Shared-Memory; Distributed Shared Memory; Network-on-Chip; RISC; MIPS; Virtual Channel; Wormhole Router; NoC Routing Algorithm,,,,,,,,
Silvio Micali,"Chen, Jing; Micali, Silvio",Theory of Computation,2010-12-30T09:30:03Z,2010-12-30T09:30:03Z,2010-12-20,http://hdl.handle.net/1721.1/60371,"In mechanism design, the traditional way of modeling the players' incomplete information about their opponents is ""assuming a Bayesian."" This assumption, however, is very strong and does not hold in many real applications. Accordingly, we put forward (1) a set-theoretic way to model the knowledge that a player might have about his opponents, and (2) a new class of mechanisms capable of leveraging such more conservative knowledge in a robust way. In auctions of a single good, we show that such a new mechanism can perfectly guarantee a revenue benchmark (always lying in between the second highest and the highest valuation) that no classical mechanism can even approximate in any robust way.",23 p.,MIT-CSAIL-TR-2010-060,Conservative Rationalizability and The Second-Knowledge Mechanism,,,,,,,,,,,
Silvio Micali,"Azar, Pablo; Chen, Jing; Micali, Silvio",Theory of Computation,2010-12-30T09:15:11Z,2010-12-30T09:15:11Z,2010-12-20,http://hdl.handle.net/1721.1/60370,"Classical Bayesian mechanism design is ""centralized,"" that is, the designer is assumed to know the distribution D from which the players' type profile has been drawn. We instead investigate a very ""decentralized"" Bayesian model, where the designer has no knowledge at all, and each player only has some probabilistic information about D. For this decentralized model and many contexts of interest, where the goal is to maximize revenue, we show that, for arbitrary type distributions D (in particular, correlated ones), it is possible to design mechanisms matching to a significant extent the performance of the optimal centralized mechanisms. Our results are ""existential"" for a broad class of contexts (including combinatorial auctions) and ""constructive"" for auctions of a single good.",18 p.,MIT-CSAIL-TR-2010-059,Conservative-Bayesian Mechanism Design,,,,,,,,,,,
Tomaso Poggio,"Leibo, Joel Z; Mutch, Jim; Rosasco, Lorenzo; Ullman, Shimon; Poggio, Tomaso",Center for Biological and Computational Learning (CBCL),2011-01-04T22:30:15Z,2011-01-04T22:30:15Z,2010-12-30,http://hdl.handle.net/1721.1/60378,"Invariance to various transformations is key to object recognition but existing definitions of invariance are somewhat confusing while discussions of invariance are often confused. In this report, we provide an operational definition of invariance by formally defining perceptual tasks as classification problems. The definition should be appropriate for physiology, psychophysics and computational modeling. For any specific object, invariance can be trivially ``learned'' by memorizing a sufficient number of example images of the transformed object. While our formal definition of invariance also covers such cases, this report focuses instead on invariance from very few images and mostly on invariances from one example. Image-plane invariances -- such as translation, rotation and scaling -- can be computed from a single image for any object. They are called generic since in principle they can be hardwired or learned (during development) for any object. In this perspective, we characterize the invariance range of a class of feedforward architectures for visual recognition that mimic the hierarchical organization of the ventral stream. We show that this class of models achieves essentially perfect translation and scaling invariance for novel images. In this architecture a new image is represented in terms of weights of ""templates"" (e.g. ""centers"" or ""basis functions"") at each level in the hierarchy. Such a representation inherits the invariance of each template, which is implemented through replication of the corresponding ""simple"" units across positions or scales and their ""association"" in a ""complex"" unit. We show simulations on real images that characterize the type and number of templates needed to support the invariant recognition of novel objects. We find that 1) the templates need not be visually similar to the target objects and that 2) a very small number of them is sufficient for good recognition. These somewhat surprising empirical results have intriguing implications for the learning of invariant recognition during the development of a biological organism, such as a human baby. In particular, we conjecture that invariance to translation and scale may be learned by the association -- through temporal contiguity -- of a small number of primal templates, that is patches extracted from the images of an object moving on the retina across positions and scales. The number of templates can later be augmented by bootstrapping mechanisms using the correspondence provided by the primal templates -- without the need of temporal contiguity.",27 p.,MIT-CSAIL-TR-2010-061; CBCL-294,Learning Generic Invariances in Object Recognition:  Translation and Scale,Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported,http://creativecommons.org/licenses/by-nc-nd/3.0/,vision; object recognition; generic transformations; selectivity-invariance trade-off; primal templates,CBCL-291,,,,,,,
Tomaso Poggio,"Mutch, Jim; Leibo, Joel Z; Smale, Steve; Rosasco, Lorenzo; Poggio, Tomaso",Center for Biological and Computational Learning (CBCL),2011-01-04T22:30:28Z,2011-01-04T22:30:28Z,2010-12-31,http://hdl.handle.net/1721.1/60379,"Neurons in inferotemporal cortex that respond similarly to many pairs of mirror-symmetric images -- for example, 45 degree and -45 degree views of the same face -- have often been reported. The phenomenon seemed to be an interesting oddity. However, the same phenomenon has also emerged in simple hierarchical models of the ventral stream. Here we state a theorem characterizing sufficient conditions for this curious invariance to occur in a rather large class of hierarchical networks and demonstrate it with simulations.",7 p.,MIT-CSAIL-TR-2010-062; CBCL-295,Neurons That Confuse Mirror-Symmetric Object Views,Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported,http://creativecommons.org/licenses/by-nc-nd/3.0/,Mirror Symmetry; Object Recognition,,,,,,,,
Patrick Winston,"Finlayson, Mark Alan; Kulkarni, Nidhi",Genesis,2011-05-09T19:30:20Z,2011-05-09T19:30:20Z,2011,http://hdl.handle.net/1721.1/62793,"jMWE is a Java library for constructing and testing Multi-Word Expression detectors. The library has three main facilities: (1) a detector API, (2) a MWE index facility, and (3) a test harness. This is version 1.0.0 of the library. It contains the source code, compiled binary files, javadocs, a user's manual (pdf), and data for constructing a default MWE index. The freely available version of jMWE is licensed for use for non-commercial purposes only, as long as proper acknowledgment is made. Details can be found in the license, which is included at the end of this document. The copyright on the software is owned by MIT; if you wish to use the software for commercial purposes, please contact the MIT Technology Licensing Office for more information on how to obtain a commercial license.",1816402 bytes,,jMWE v1.0.0,Creative Commons Attribution-NonCommercial 3.0 Unported,http://creativecommons.org/licenses/by-nc/3.0/,Java; Multi-word Expressions; MWE; Detection,,"""June 2011.""",application/zip,"Finlayson, Mark A. and Kulkarni, Nidhi (2011) ""Detecting Multi-Word Expressions improves Word Sense Disambiguation"", in Proceedings of the 2011 Workshop on Multiword Expressions, held at ACL'2011 in Portland, OR",,,,
Brian Williams,"Conrad, Patrick R; Williams, Brian C",Model-based Embedded and Robotic Systems,2011-01-19T23:30:14Z,2011-01-19T23:30:14Z,2011-01-15,http://hdl.handle.net/1721.1/60674,"Dynamic plan execution strategies allow an autonomous agent to respond to uncertainties, while improving robustness and reducing the need for an overly conservative plan. Executives have improved robustness by expanding the types of choices made dynamically, such as selecting alternate methods. However, in some approaches to date, these additional choices often induce significant storage requirements to make flexible execution possible. This paper presents a novel system called Drake, which is able to dramatically reduce the storage requirements in exchange for increased execution time for some computations. Drake frames a plan as a collection of related Simple Temporal Problems, and executes the plan with a fast dynamic scheduling algorithm. This scheduling algorithm leverages prior work in Assumption-based Truth Maintenance Systems to compactly record and reason over the family of Simple Temporal Problems. We also allow Drake to reason over temporal uncertainty and choices by using prior work in Simple Temporal Problems with Uncertainty, which can guarantee correct execution, regardless of the uncertain outcomes. On randomly generated structured plans with choice, framed as either Temporal Plan Networks or Disjunctive Temporal Problems, we show a reduction in the size of the solution set of around four orders of magnitude, compared to prior art.",70 p.,MIT-CSAIL-TR-2011-002,Flexible Execution of Plans with Choice and Uncertainty,,,dynamic execution; scheduling; Simple Temporal Problems; dispatching; temporal plan,,,,,,,,
Martin Rinard,"Misailovic, Sasa; Roy, Daniel M.; Rinard, Martin",Computer Architecture,2011-01-19T23:45:03Z,2011-01-19T23:45:03Z,2011-01-19,http://hdl.handle.net/1721.1/60675,"We present a new foundation for the analysis and transformation of computer programs.Standard approaches involve the use of logical reasoning to prove that the applied transformation does not change the observable semantics of the program. Our approach, in contrast, uses probabilistic and statistical reasoning to justify the application of transformations that may change, within probabilistic bounds, the result that the program produces. Loop perforation transforms loops to execute fewer iterations. We show how to use our basic approach to justify the application of loop perforation to a set of computational patterns. Empirical results from computations drawn from the PARSEC benchmark suite demonstrate that these computational patterns occur in practice. We also outline a specification methodology that enables the transformation of subcomputations and discuss how to automate the approach.",22 p.,MIT-CSAIL-TR-2011-003,Probabilistic and Statistical Analysis of Perforated Patterns,,,,,,,,,,,
Tomaso Poggio,"Baldassarre, Luca; Rosasco, Lorenzo; Barla, Annalisa; Verri, Alessandro",Center for Biological and Computational Learning (CBCL),2011-02-01T20:00:05Z,2011-02-01T20:00:05Z,2011-01-24,http://hdl.handle.net/1721.1/60875,"In this paper we study a class of regularized kernel methods for vector-valued learning which are based on filtering the spectrum of the kernel matrix. The considered methods include Tikhonov regularization as a special case, as well as interesting alternatives such as vector-valued extensions of L2 boosting. Computational properties are discussed for various examples of kernels for vector-valued functions and the benefits of iterative techniques are illustrated. Generalizing previous results for the scalar case, we show finite sample bounds for the excess risk of the obtained estimator and, in turn, these results allow to prove consistency both for regression and multi-category classification. Finally, we present some promising results of the proposed algorithms on artificial and real data.",37 p.,MIT-CSAIL-TR-2011-004; CBCL-296,Multi-Output Learning via Spectral Filtering,,,"Computational Learning, Multi-Output Learning, Spectral Methods",,,,,,,,
Nickolai Zeldovich,"Popa, Raluca Ada; Zeldovich, Nickolai; Balakrishnan, Hari",Parallel and Distributed Operating Systems,2011-02-01T20:15:04Z,2011-02-01T20:15:04Z,2011-01-26,http://hdl.handle.net/1721.1/60876,"CryptDB is a DBMS that provides provable and practical privacy in the face of a compromised database server or curious database administrators. CryptDB works by executing SQL queries over encrypted data. At its core are three novel ideas: an SQL-aware encryption strategy that maps SQL operations to encryption schemes, adjustable query-based encryption which allows CryptDB to adjust the encryption level of each data item based on user queries, and onion encryption to efficiently change data encryption levels. CryptDB only empowers the server to execute queries that the users requested, and achieves maximum privacy given the mix of queries issued by the users. The database server fully evaluates queries on encrypted data and sends the result back to the client for final decryption; client machines do not perform any query processing and client-side applications run unchanged. Our evaluation shows that CryptDB has modest overhead: on the TPC-C benchmark on Postgres, CryptDB reduces throughput by 27% compared to regular Postgres. Importantly, CryptDB does not change the innards of existing DBMSs: we realized the implementation of CryptDB using client-side query rewriting/encrypting, user-defined functions, and server-side tables for public key information. As such, CryptDB is portable; porting CryptDB to MySQL required changing 86 lines of code, mostly at the connectivity layer.",13 p.,MIT-CSAIL-TR-2011-005,CryptDB: A Practical Encrypted Relational DBMS,Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported,http://creativecommons.org/licenses/by-nc-nd/3.0/,confidentiality; privacy; cloud computing; outsourced databases; queries over encrypted data,,,,,,,,
Nick Roy,"Kollar, Thomas; Dickerson, Steven; Tellex, Stefanie; Banerjee, Ashis Gopal; Walter, Matthew R.; Teller, Seth; Roy, Nicholas","Robotics, Vision & Sensor Networks",2011-02-02T22:45:06Z,2011-02-02T22:45:06Z,2011-02-01,http://hdl.handle.net/1721.1/60883,We describe a new model for understanding hierarchical natural language commands for robot navigation and manipulation. The model has three components: a semantic structure that captures the hierarchical structure of language; a cost function that maps the command's semantic structure to the robot's sensorimotor capabilities; and an efficient search method for finding the lowest-cost plan. We present a proof-of-concept system that carries out navigation commands in a simulated setting.,2 p.,MIT-CSAIL-TR-2011-007,Towards Understanding Hierarchical Natural Language Commands for Robotic Navigation and Manipulation,,,graphical models; SDC; ESDC; grounding,,,,,,,,
Martin Rinard,"Ganesh, Vijay; Minnes, Mia; Solar-Lezama, Armando; Rinard, Martin",Computer Architecture,2011-02-01T20:15:11Z,2011-02-01T20:15:11Z,2011-02-01,http://hdl.handle.net/1721.1/60877,"We prove several decidability and undecidability results for the satisfiability/validity problem of formulas over a language of finite-length strings and integers (interpreted as lengths of strings). The atomic formulas over this language are equality over string terms (word equations), linear inequality over length function (length constraints), and membership predicate over regularexpressions (r.e.). These decidability questions are important in logic, program analysis and formal verification. Logicians have been attempting to resolve some of these questions for many decades, while practical satisfiability procedures for these formulas are increasingly important in the analysis of string-manipulating programs such as web applications and scripts. We prove three main theorems. First, we consider Boolean combination of quantifier-free formulas constructed out of word equations and length constraints. We show that if word equations can be converted to a solved form, a form relevant in practice, then the satisfiability problem for Boolean combination of word equations and length constraints is decidable. Second, we show that the satisfiability problem for word equations in solved form that areregular, length constraints and r.e. membership predicate is also decidable. Third, we show that the validity problem for the set of sentences written as a forall-exists quantifier alternation applied to positive word equations is undecidable. A corollary of this undecidability result is that this set is undecidable even with sentences with at most two occurrences of a string variable.",16 p.,MIT-CSAIL-TR-2011-006,What is Decidable about Strings?,,,Theories of strings; decidability; undecidability; word equations; regular expressions; JavaScript; Formal methods; Program Analysis,,,,,,,,
Dina Katabi,"Jakubczak, Szymon; Katabi, Dina",Networks & Mobile Systems,2011-02-22T21:30:19Z,2011-02-22T21:30:19Z,2011-02-15,http://hdl.handle.net/1721.1/61009,"Video broadcast and mobile video challenge the conventional wireless design. In broadcast and mobile scenarios the bit rate supported by the channel differs across receivers and varies quickly over time. The conventional design however forces the source to pick a single bit rate and degrades sharply when the channel cannot not support the chosen bit rate. This paper presents SoftCast, a clean-slate design for wireless video where the source transmits one video stream that each receiver decodes to a video quality commensurate with its specific instantaneous channel quality. To do so, SoftCast ensures the samples of the digital video signal transmitted on the channel are linearly related to the pixels' luminance. Thus, when channel noise perturbs the transmitted signal samples, the perturbation naturally translates into approximation in the original video pixels. Hence, a receiver with a good channel (low noise) obtains a high fidelity video, and a receiver with a bad channel (high noise) obtains a low fidelity video. We implement SoftCast using the GNURadio software and the USRP platform. Results from a 20-node testbed show that SoftCast improves the average video quality (i.e., PSNR) across broadcast receivers in our testbed by up to 5.5dB. Even for a single receiver, it eliminates video glitches caused by mobility and increases robustness to packet loss by an order of magnitude.",14 p.,MIT-CSAIL-TR-2011-008,SoftCast: Clean-slate Scalable Wireless Video,,,,,,,,,,,
Silvio Micali,"Chiesa, Alessandro; Micali, Silvio; Zhu, Zeyuan Allen",Theory of Computation,2011-02-22T21:30:08Z,2011-02-22T21:30:08Z,2011-02-16,http://hdl.handle.net/1721.1/61008,"We investigate mechanism design when the players do not exactly know their types, but have instead only partial information about them.",18 p.,MIT-CSAIL-TR-2011-009,Mechanism Design With Approximate Player Types,,,Type uncertainty; Mechanism Design; Auctions; Social Welfare,,,,,MIT-CSAIL-TR-2011-024,http://hdl.handle.net/1721.1/62296,,
Silvio Micali,"Chiesa, Alessandro; Micali, Silvio; Zhu, Zeyuan Allen",Theory of Computation,2011-04-21T18:15:33Z,2011-04-21T18:15:33Z,2011-02-16,http://hdl.handle.net/1721.1/62296,"In mechanism design, we replace the strong assumption that each player knows his own payoff type EXACTLY with the more realistic assumption that he knows it only APPROXIMATELY. Specifically, we study the classical problem of maximizing social welfare in single-good auctions when players know their true valuations only within a constant multiplicative factor d in (0,1). Our approach is deliberately non-Bayesian and very conservative: each player i only knows that his true valuation is one among finitely many values in a d-APPROXIMATE SET, Ki, and his true valuation is ADVERSARIALLY and SECRETLY chosen in Ki at the beginning of the auction. We prove tight upper and lower bounds for the fraction of the maximum social welfare achievable in our model, in either dominant or undominated strategies, both via deterministic and probabilistic mechanisms. The landscape emerging is quite unusual and intriguing.",30 p.,MIT-CSAIL-TR-2011-024,Mechanism Design with Approximate Valuations,,,,MIT-CSAIL-TR-2011-009,,,,,http://hdl.handle.net/1721.1/61008,,
Nancy Lynch,"Khabbazian, Majid; Kowalski, Dariusz; Kuhn, Fabian; Lynch, Nancy",Theory of Computation,2011-03-03T20:15:08Z,2011-03-03T20:15:08Z,2011-02-23,http://hdl.handle.net/1721.1/61391,"In much of the theoretical literature on global broadcast algorithms for wireless networks, issues of message dissemination are considered together with issues of contention management. This combination leads to complicated algorithms and analysis, and makes it difficult to extend the work to more difficult communication problems. In this paper, we present results aimed at simplifying such algorithms and analysis by decomposing the treatment into two levels, using abstract ""MAC layer"" specifications to encapsulate contention management. We use two different abstract MAC layers: the basic layer of Kuhn, Lynch, and Newport, and a new probabilistic layer. We first present a typical randomized contention-management algorithm for a standard graph-based radio network model and show that it implements both abstract MAC layers. Then we combine this algorithm with greedy algorithms for single-message and multi-message global broadcast and analyze the combinations, using both abstract MAC layers as intermediate layers. Using the basic MAC layer, we prove a bound of O(D log(n / epsilon) log(Delta)) for the time to deliver a single message everywhere with probability 1 - epsilon, where D is the network diameter, n is the number of nodes, and Delta is the maximum node degree. Using the probabilistic layer, we prove a bound of O((D + log(n/epsilon)) log(Delta)), which matches the best previously-known bound for single-message broadcast over the physical network model. For multi-message broadcast, we obtain bounds of O((D + k Delta) log(n/epsilon) log(Delta)) using the basic layer and O((D + k Delta log(n/epsilon)) log(Delta)) using the probabilistic layer, for the time to deliver a message everywhere in the presence of at most k concurrent messages.",39 p.,MIT-CSAIL-TR-2011-010,Decomposing Broadcast Algorithms Using Abstract MAC Layers,,,broadcast protocol; contention management; wireless network algorithms; multi-message broadcast; global broadcast,,,,,,,"Author Lynch's research is supported by AFOSR contract FA9550-08-1-0159 and NSF grants CCF-0726514, CNS-0715397, CCF-0937274, and NSF-PURDUE-STC Award 0939370-CCF.  Author Kowalski's research is supported by the Engineering and Physical Sciences Research Council [grant numbers EP/G023018/1,
EP/H018816/1].",
,"Poggio, Tomaso",Center for Biological and Computational Learning (CBCL),2011-03-04T21:30:04Z,2011-03-04T21:30:04Z,2011-03-04,http://hdl.handle.net/1721.1/61424,"Excerpts from a talk given by Tomaso Poggio in Tübingen on the opening ofthe Werner Reichardt Centrun für Integrative Neurowissenschaften, December 8, 2008.",16 p.,MIT-CSAIL-TR-2011-011; CBCL-297,Werner Reichardt: the man and his scientific legacy,,,vision; fly vision; theory; figure-ground discrimination; motion detection,,,,,,,,"Geiger, Gadi"
Anant Agarwal,"Wentzlaff, David; Gruenwald, Charles, III; Beckmann, Nathan; Belay, Adam; Kasture, Harshad; Modzelewski, Kevin; Youseff, Lamia; Miller, Jason E.; Agarwal, Anant",Computer Architecture,2011-03-09T18:45:21Z,2011-03-09T18:45:21Z,2011-03-09,http://hdl.handle.net/1721.1/61640,"Current monolithic operating systems are designed for uniprocessor systems, and their architecture reflects this. The rise of multicore and cloud computing is drastically changing the tradeoffs in operating system design. The culture of scarce computational resources is being replaced with one of abundant cores, where spatial layout of processes supplants time multiplexing as the primary scheduling concern. Efforts to parallelize monolithic kernels have been difficult and only marginally successful, and new approaches are needed. This paper presents fleets, a novel way of constructing scalable OS services. With fleets, traditional OS services are factored out of the kernel and moved into user space, where they are further parallelized into a distributed set of concurrent, message-passing servers. We evaluate fleets within fos, a new factored operating system designed from the ground up with scalability as the first-order design constraint. This paper details the main design principles of fleets, and how the system architecture of fos enables their construction. We describe the design and implementation of three critical fleets (network stack, page allocation, and file system) and compare with Linux. These comparisons show that fos achieves superior performance and has better scalability than Linux for large multicores; at 32 cores, fos's page allocator performs 4.5 times better than Linux, and fos's network stack performs 2.5 times better. Additionally, we demonstrate how fleets can adapt to changing resource demand, and the importance of spatial scheduling for good performance in multicores.",13 p.,MIT-CSAIL-TR-2011-012,Fleets: Scalable Services in a Factored Operating System,,,multicore; scalable operating system,,,,,,,,
